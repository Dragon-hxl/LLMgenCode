Task 0 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
Task 0 gens 2 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return bin(n1+n2)[2:]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 1 passed True
Task 0 gens 10 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    carry = 0
    while n1 > 0 or n2 > 0 or carry:
        sum = (n1 % 2) + (n2 % 2) + carry
        carry = sum // 2
        result = str(sum % 2) + result
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return bin(n1+n2)[2:]
    if len(bin(n1)[2:] + bin(n2)[2:]) > 32:
        return str(n1+n2)

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return bin(n1+n2)[2:]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    ans = ""
    while (n1 > 0) or (n2 > 0):
        if (n1 & 1) + (n2 & 1) > 1:
            ans = "1" + ans
        else:
            ans = "0" + ans
        n1 >>= 1
        n2 >>= 1
    return ans

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return "".join(str(int(c1) ^ int(c2)) for c1, c2 in zip("{0:b}".format(n1), "{0:b}".format(n2)))

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    sum = ''
    carry = 0
    while n1 > 0 or n2 > 0:
        sum = str(carry) + str(int(n1 % 2) + int(n2 % 2)) + sum
        carry = int(n1 % 2) + int(n2 % 2) > 1
        n1 = n1 // 2
        n2 = n2 // 2
    return sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        remainder = (n1 % 2) + (n2 % 2)
        if remainder >= 2:
            result = '1' + result
            remainder -= 2
        else:
            result = '0' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return bin(n1 + n2)[2:]
    if len(bin(n1)[2:] + bin(n2)[2:]) > 32:
        return str(n1 + n2)

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    carry = 0
    while n1 > 0 or n2 > 0 or carry:
        sum = (n1 % 2) + (n2 % 2) + carry
        carry = sum // 2
        result = str(sum % 2) + result
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return format(n1+n2, 'b')

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return bin(n1+n2)[2:]
    if len(bin(n1)[2:] + bin(n2)[2:]) > 32:
        return str(n1+n2)

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = 0
    while n1 > 0 or n2 > 0:
        result = result * 2 + (n1 % 2) + (n2 % 2)
        n1 = n1 // 2
        n2 = n2 // 2
    return format(result, 'b')

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += '0'
        else:
            result += '1'
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    return bin(n1+n2)[2:]
    if len(bin(n1)[2:] + bin(n2)[2:]) > 32:
        return str(n1+n2)

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = 0
    while n1 > 0 or n2 > 0:
        result *= 2
        result += n1 % 2
        result += n2 % 2
        n1 //= 2
        n2 //= 2
    return bin(result)[2:]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += '0'
        else:
            result += '1'
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += '0'
        else:
            result += '1'
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if n1 % 2 + n2 % 2 == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 //= 2
        n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    n1 = "0" * (len(n2) - len(n1)) + n1
    n2 = "0" * (len(n1) - len(n2)) + n2
    result = ""
    while n1 or n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = '0' + result
        else:
            result = '1' + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = int(n1[-1]) + 0
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = int(n2[-1]) + 0
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if n1 % 2 + n2 % 2 == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 //= 2
        n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ''
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += '0'
        else:
            result += '1'
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    n1 = "0" * (len(n2) - len(n1)) + n1
    n2 = "0" * (len(n1) - len(n2)) + n2
    result = ""
    while n1 or n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = int(n1[-1]) + 0
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = int(n2[-1]) + 0
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if n1 % 2 + n2 % 2 == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 //= 2
        n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        if int(n1[-1]) + int(n2[-1]) == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        if int(n1[-1]) + 0 == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
    while n2:
        if int(n2[-1]) + 0 == 0:
            result = "0" + result
        else:
            result = "1" + result
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ''
    while n1 != 0 and n2 != 0:
        if n1 % 2 + n2 % 2 == 2:
            binary_sum = '1' + binary_sum
        else:
            binary_sum = '0' + binary_sum
        n1 //= 2
        n2 //= 2
    if n1 != 0:
        while n1 != 0:
            if n1 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n1 //= 2
    elif n2 != 0:
        while n2 != 0:
            if n2 % 2 == 1:
                binary_sum = '1' + binary_sum
            else:
                binary_sum = '0' + binary_sum
            n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    n1 = "0" * (len(n2) - len(n1)) + n1
    n2 = "0" * (len(n1) - len(n2)) + n2
    result = ""
    while n1 or n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 or n2:
        if n1 and n2:
            if int(n1[-1]) + int(n2[-1]) > 1:
                result = "1" + result
                n1 = n1[:-1]
                n2 = n2[:-1]
            else:
                result = "0" + result
                n1 = n1[:-1]
                n2 = n2[:-1]
        elif n1:
            if int(n1[-1]) > 0:
                result = "1" + result
                n1 = n1[:-1]
            else:
                result = "0" + result
                n1 = n1[:-1]
        else:
            if int(n2[-1]) > 0:
                result = "1" + result
                n2 = n2[:-1]
            else:
                result = "0" + result
                n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        if int(n1[-1]) + int(n2[-1]) == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        if int(n1[-1]) + 0 == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
    while n2:
        if int(n2[-1]) + 0 == 0:
            result = "0" + result
        else:
            result = "1" + result
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    n1 = "0" * (len(n2) - len(n1)) + n1
    n2 = "0" * (len(n1) - len(n2)) + n2
    result = ""
    while n1 or n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if n1 % 2 + n2 % 2 == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 //= 2
        n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        if (n1 % 2) + (n2 % 2) == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if (n1 % 2 + n2 % 2) == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 //= 2
        n2 //= 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if n1 % 2 + n2 % 2 == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 = n1 // 2
        n2 = n2 // 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 0 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 or n2:
        if n1 and n2:
            if int(n1[-1]) + int(n2[-1]) > 1:
                result = "1" + result
                n1 = n1[:-1]
                n2 = n2[:-1]
            else:
                result = "0" + result
                n1 = n1[:-1]
                n2 = n2[:-1]
        elif n1:
            if int(n1[-1]) > 0:
                result = "1" + result
                n1 = n1[:-1]
            else:
                result = "0" + result
                n1 = n1[:-1]
        else:
            if int(n2[-1]) > 0:
                result = "1" + result
                n2 = n2[:-1]
            else:
                result = "0" + result
                n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1 // 2
        n2 = n2 // 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1 // 2
        n2 = n2 // 2
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = str(bin(n1)[2:])
    n2 = str(bin(n2)[2:])
    result = ""
    while n1 and n2:
        sum = (int(n1[-1])) + (int(n2[-1]))
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        sum = (int(n1[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 = n1[:-1]
    while n2:
        sum = (int(n2[-1])) + (0)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    result = ""
    while n1 and n2:
        if int(n1[-1]) + int(n2[-1]) == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    while n1:
        if int(n1[-1]) + 0 == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
    while n2:
        if int(n2[-1]) + 0 == 0:
            result = "0" + result
        else:
            result = "1" + result
        n2 = n2[:-1]
    return result[::-1]

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    result = ""
    while n1 > 0 or n2 > 0:
        sum = (n1 % 2) + (n2 % 2)
        if sum == 0:
            result += "0"
        else:
            result += "1"
        n1 //= 2
        n2 //= 2
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    binary_sum = ""
    while n1 != 0 or n2 != 0:
        if (n1 % 2 + n2 % 2) == 0:
            binary_sum = "0" + binary_sum
        else:
            binary_sum = "1" + binary_sum
        n1 = n1 // 2
        n2 = n2 // 2
    return binary_sum

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which sum two positive integers and return the answer in binary. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'binary_add' will take the arguments 'n1', an int and 'n2', an int. It will return a str.
def binary_add(n1, n2):

    n1 = bin(n1)[2:]
    n2 = bin(n2)[2:]
    n1 = "0" * (len(n2) - len(n1)) + n1
    n2 = "0" * (len(n1) - len(n2)) + n2
    result = ""
    while n1 or n2:
        sum = int(n1[-1]) + int(n2[-1])
        if sum == 0:
            result = "0" + result
        else:
            result = "1" + result
        n1 = n1[:-1]
        n2 = n2[:-1]
    return result

def check(binary_add):
    assert binary_add(2, 3) == '101'
    assert binary_add(5, 12) == '10001'
    assert binary_add(98, 99) == '11000101'
    assert binary_add(459, 256) == '1011001011'
    assert binary_add(1111, 111111) == '11011011001011110'

check(binary_add)
result : failed: AssertionError
solution 9 passed False
Task 1 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which return the nth Fibonacci number. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fib' will take the argument 'n', an int. It will return a the nth fibonacci number.
def fib(n):

    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)

def check(fib):
    assert fib(0) == 0
    assert fib(1) == 1
    assert fib(5) == 5
    assert fib(10) == 55
    assert fib(11) == 89

check(fib)
result : passed
solution 0 passed True
Task 2 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which flattens a list of lists. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'flatten_list' will take the argument 'li', a list of lists. It will return a flattened list.
def flatten_list(li):

    return [item for sublist in li for item in sublist]

def check(flatten_list):
    assert flatten_list([[3, 9], [7, 5], [1, 1], [0, 8], [6, 7]]) == [3, 9, 7, 5, 1, 1, 0, 8, 6, 7]
    assert flatten_list([[0, 9], [8, 2], [1, 1], [3, 5], [4, 2]]) == [0, 9, 8, 2, 1, 1, 3, 5, 4, 2]
    assert flatten_list([[6, 1], [2, 3], [4, 7], [1, 5], [5, 0]]) == [6, 1, 2, 3, 4, 7, 1, 5, 5, 0]
    assert flatten_list([[6, 1], [0, 9], [9, 8], [3, 0], [6, 4]]) == [6, 1, 0, 9, 9, 8, 3, 0, 6, 4]
    assert flatten_list([[1, 4], [0, 9], [2, 6], [3, 5], [5, 1]]) == [1, 4, 0, 9, 2, 6, 3, 5, 5, 1]

check(flatten_list)
result : passed
solution 0 passed True
Task 3 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
Task 3 gens 2 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2 * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
Task 3 gens 8 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 360 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) * 180 // n // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return n * (n - 3) // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2 * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * (n - 3) / n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) * 180 // n // (n - 3)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
Task 3 gens 10 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return n * (n - 3) * 180 // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 360 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * (n - 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * n * (n - 3) // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) * 180 // n // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2 * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) * 180 // n // (n - 3)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return (n * (n - 3)) // 2 * 180 / (n - 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 9 passed False
Task 3 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * (n - 3)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * (n - 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    return n * (n - 3) * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return n * (n - 3) * 180 // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return ((n-2)*180)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 360 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return int((n * (n - 3)) * 180 / 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * (n * (n - 3)) // (n - 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * n * (n - 3) // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 9 passed False
Task 3 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n* 100 - n * 30

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - (n - 3) * 120

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n * 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    else:
        return n * (n - 3) * 180 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 180 * (n - 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n%2==0:
        return n*(n-3)*180//n
    else:
        return None

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return 360 // n

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    return n * (n - 3) * 180 // 2

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 9 passed False
Task 3 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return ((n * 90) - 90)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return int((n * 180 - n * (n - 3) * 90) / 2)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - (n - 3) * 120

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n)* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 100) - (n * 30)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n* 100 - n * 30

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return (n * 90)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    total = (n * 100) - (n * 30)
    return total

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 9 passed False
Task 3 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return ((n * 90) - 90)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 72) - (n * 12)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return 360 + n* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n)* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return ((n - 2) * 180) + 60

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - (n - 3) * 120

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return ((n-2)*180)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 100) - (n * 30)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return (n * 180)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 9 passed False
Task 3 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    if n == 7:
        return 420
    if n == 8:
        return 360
    if n == 9:
        return 720
    if n == 10:
        return 1260
    return 360 + n * 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 72) - (n * 12)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return n * 72 - n * 12

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return (n * 90) - 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return 360 + n* 90

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    elif n == 3:
        return 120
    elif n == 4:
        return 360
    else:
        return ((n * 90) - 90)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return n * 100 - n * 30

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return ((n-2)*180) + ((n-3)*60)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    return ((n - 2) * 180) + (n * 90)

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the sum of the interior angles for an n sided shape, or None if the shape cannot exist. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'int_angle' will take the argument 'n', an int. It will return an int.
def int_angle(n):

    if n < 3:
        return None
    if n == 3:
        return 120
    if n == 4:
        return 360
    total = (n * 100) - (n * 30)
    return total

def check(int_angle):
    assert int_angle(2) == None
    assert int_angle(98) == 17280
    assert int_angle(-2) == None
    assert int_angle(3) == 180
    assert int_angle(4) == 360
    assert int_angle(5) == 540
    assert int_angle(6) == 720
    assert int_angle(7) == 900
    assert int_angle(8) == 1080
    assert int_angle(12) == 1800

check(int_angle)
result : failed: AssertionError
solution 9 passed False
Task 4 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which return the negative of each value of the list. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'invert_list' will take the argument 'list', a list of integers. It will return a list.
def invert_list(list):

    return [-x for x in list]

def check(invert_list):
    assert invert_list([1, 2, 3, 4]) == [-1, -2, -3, -4]
    assert invert_list([-2, 0, 5, -100]) == [2, 0, -5, 100]
    assert invert_list([20, 40, 60, -8000]) == [-20, -40, -60, 8000]
    assert invert_list([-1, -2, -9999]) == [1, 2, 9999]

check(invert_list)
result : passed
solution 0 passed True
Task 5 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : failed: name 'is_not_prime' is not defined
solution 0 passed False
Task 5 gens 10 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list
def is_not_prime(n):
    if n <= 1:
        return True
    for i in range(2, n):
        if n % i == 0:
            return True
    return False

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : failed: name 'is_not_prime' is not defined
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2, p + 1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : failed: name 'is_not_prime' is not defined
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list
def is_not_prime(n):
    if n == 1 or n == 0:
        return True
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return True
    return False

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list
def is_not_prime(n):
    if n < 2:
        return True
    for i in range(2, n):
        if n % i == 0:
            return True
    return False

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2, p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : failed: name 'is_not_prime' is not defined
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2, p + 1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list
def is_not_prime(p):
    if p == 1:
        return True
    for i in range(2, p):
        if p % i == 0:
            return True
    return False

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2, p + 1):
        if is_prime(i):
            prime_list.append(i)
    return prime_list
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list
def is_not_prime(n):
    for i in range(2,n):
        if n % i == 0:
            return True
    return False

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which finds and lists primes up to p. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'prime_list' will take the argument 'p', an int > 0. It will return a list of primes up to p.
def prime_list(p):

    prime_list = []
    for i in range(2,p+1):
        if is_not_prime(i) == False:
            prime_list.append(i)
    return prime_list
def is_not_prime(p):
    for i in range(2,p):
        if p % i == 0:
            return True
    return False

def check(prime_list):
    assert prime_list(-3) == []
    assert prime_list(3) == [2, 3]
    assert prime_list(11) == [2, 3, 5, 7, 11]
    assert prime_list(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

check(prime_list)
result : passed
solution 9 passed True
Task 6 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which determines if a string has all unique characters. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'string_has_unique_chars' will take the argument 's', a string. It will return a boolean.
def string_has_unique_chars(s):

    return len(set(s)) == len(s)

def check(string_has_unique_chars):
    assert string_has_unique_chars('aasssssgghhhsaa') == False
    assert string_has_unique_chars('dfddddhhkdkkk') == False
    assert string_has_unique_chars('a0sgjLd') == True
    assert string_has_unique_chars('abbbbbbbb') == False
    assert string_has_unique_chars('abc') == True
    assert string_has_unique_chars('') == True

check(string_has_unique_chars)
result : passed
solution 0 passed True
Task 7 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which approximate the square root of a positive integer with an Newton's iterative method. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'Newton' will take the argument 'x', an int. It will return a float.
def Newton(x):

    return x ** 0.5

def check(Newton):
    assert Newton(4) == 2.0000000929222947
    assert Newton(536870911) == 23170.474984341603
    assert Newton(100000) == 316.2277660168379
    assert Newton(21) == 4.582575694960138
    assert Newton(0) == 0.0009765625

check(Newton)
result : failed: AssertionError
solution 0 passed False
Task 8 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
Task 8 gens 2 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
Task 8 gens 5 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list.sort()
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for string in string_list:
        sorted_string_list.append(string)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(my_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : failed: name 'my_list' is not defined
solution 4 passed False
Task 8 gens 8 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    return sorted(sorted_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list.sort()
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for string in string_list:
        sorted_string_list.append(string)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sortedList = []
    for string in string_list:
        sortedList.append(string)
    sortedList.sort()
    return sortedList

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(my_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : failed: name 'my_list' is not defined
solution 7 passed False
Task 8 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = []
    for i in range(0, len(string_list)):
        
        sorted_strings.append(string_list[i])
    sorted_strings.sort()
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    return sorted(sorted_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sortedList = []
    for string in string_list:
        sortedList.append(string)
    sortedList.sort()
    return sortedList

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for string in string_list:
        sorted_string_list.append(string)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list.sort()
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sortedList = sorted(string_list)
    return sortedList

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 8 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = sorted(string_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = sorted(string_list)
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for element in string_list:
        sorted_string_list.append(element)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list.sort()
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = sorted(string_list)
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = sorted(string_list)
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sortedList = []
    for string in string_list:
        sortedList.append(string)
    sortedList.sort()
    return sortedList

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 8 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for element in string_list:
        sorted_string_list.append(element)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = sorted(string_list)
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = sorted(string_list)
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = sorted(string_list)
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = []
    for string in string_list:
        result.append(string)
    return sorted(result)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sortedList = []
    for string in string_list:
        sortedList.append(string)
    sortedList.sort()
    return sortedList

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list.sort()
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 8 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for element in string_list:
        sorted_string_list.append(element)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = sorted(string_list)
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = []
    for string in string_list:
        result.append(string)
    return sorted(result)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = sorted(string_list)
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    import string
    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for string in string_list:
        sorted_string_list.append(string)
    return sorted(sorted_string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = sorted(string_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 8 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = sorted(string_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list = sorted(string_list)
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = sorted(string_list)
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = sorted(string_list)
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for element in string_list:
        sorted_string_list.append(element)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    import string
    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = []
    for string in string_list:
        result.append(string)
    return sorted(result)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = string_list
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 8 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = []
    for string in string_list:
        result.append(string)
    return sorted(result)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = sorted(string_list)
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_string_list = []
    for element in string_list:
        sorted_string_list.append(element)
    sorted_string_list.sort()
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = sorted(string_list)
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    import string
    sorted_string_list = sorted(string_list)
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = []
    for string in string_list:
        sorted_strings.append(string)
    sorted_strings.sort()
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = sorted(string_list)
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for word in string_list:
        sorted_list.append(word)
    sorted_list.sort()
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 8 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = []
    for word in string_list:
        result.append(word)
    result.sort()
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    import string
    sorted_string_list = sorted(string_list)
    return sorted_string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = []
    for string in string_list:
        sorted_strings.append(string)
    sorted_strings.sort()
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_list = []
    for element in string_list:
        sorted_list.append(element)
    sorted_list = sorted(sorted_list)
    return sorted_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list.sort()
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    sorted_strings = sorted(string_list)
    return sorted_strings

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return sorted(string_list)

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    string_list = sorted(string_list)
    return string_list

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    result = sorted(string_list)
    return result

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given a list of strings, return a list sorted so that the strings are in alphabetical order. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'alphabetize' will take the argument 'string_list', a l. It will return a sorted list of strings.
def alphabetize(string_list):

    return (sorted(string_list, key = lambda s: s.lower()))

def check(alphabetize):
    assert alphabetize(['c', 'a', 'b']) == ['a', 'b', 'c']
    assert alphabetize(['dafsdfasd', 'asdfasdfas', 'asdfasyhrejedgf', 'hftyuyjdfdgs']) == ['asdfasdfas', 'asdfasyhrejedgf', 'dafsdfasd', 'hftyuyjdfdgs']
    assert alphabetize(['45364563456', '5634563456456', '856785687568']) == ['45364563456', '5634563456456', '856785687568']

check(alphabetize)
result : passed
solution 9 passed True
Task 9 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which check whether permutations of an integer are a real power of two. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'check_power' will take the argument 'n', an int. It will return a Boolean.
def check_power(n):

    if n == 1:
        return True
    if n == 0:
        return False
    if n % 2 == 0:
        return check_power(n / 2)
    else:
        return False

def check(check_power):
    assert check_power(46) == True
    assert check_power(13) == False
    assert check_power(1) == True
    assert check_power(-4) == False
    assert check_power(921) == False
    assert check_power(4182410737) == True

check(check_power)
result : failed: AssertionError
solution 0 passed False
Task 10 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    elif n % 2 == 0:
        return [n] + collatz(n // 2)
    else:
        return [n] + collatz(3 * n + 1)

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
Task 10 gens 3 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    elif n % 2 == 0:
        return [n] + collatz(n // 2)
    else:
        return [n] + collatz(3 * n + 1)

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n != 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else 3*n + 1
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
Task 10 gens 10 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    elif n % 2 == 0:
        return [n] + collatz(n // 2)
    else:
        return [n] + collatz(3 * n + 1)

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        lst.append(n)
    return lst

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else n*3 + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n != 1:
        lst.append(n)
        n = n // 2 if n % 2 == 0 else 3 * n + 1
    return lst

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n != 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else 3*n + 1
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    my_list = []
    while n != 1:
        my_list.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    my_list.append(1)
    return my_list[::-1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n <= 1:
        return [n]
    steps = collatz(n // 2)
    if n % 2 == 0:
        return steps
    return steps + [3 * n + 1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n <= 1:
        return [n]
    lst = collatz(n // 2) if n % 2 == 0 else collatz((3 * n + 1) // 2)
    return lst + [n]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        n = n // 2 if n % 2 == 0 else n*3 + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        lst.append(n)
    return lst

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    lst = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        lst.append(n)
    return lst

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else n * 3 + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3*n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    seq = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3*n + 1
        seq.append(n)
    return seq

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3*n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        n = 3*n + 1 if n % 2 else n//2
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        n = 3*n + 1 if n % 2 else n//2
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else 3 * n + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result
    result = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    seq = []
    while n != 1:
        seq.append(n)
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
    seq.append(1)
    return seq

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else n * 3 + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = (n/2 if n%2==0 else 3*n+1)
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n < 1:
        return None
    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = []
    while n != 1:
        sequence.append(n)
        n = n // 2 if n % 2 == 0 else n * 3 + 1
    sequence.append(1)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else n * 3 + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        result.append(n)
        if n == 1:
            break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n <= 0:
        raise ValueError
    seq = []
    while n != 1:
        seq.append(n)
        n = 3*n+1 if n%2 else n//2
    seq.append(1)
    return seq

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    list = []
    while n > 1:
        list.append(n)
        n = n // 2 if n % 2 == 0 else 3 * n + 1
    list.append(1)
    return list

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        n = n // 2 if n % 2 == 0 else 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            n = n // 2 if n % 2 == 0 else n * 3 + 1
            result.append(n)
            if n == 1:
                break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n != 1:
        lst.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    seq = [n]
    while n != 1:
        n = 3 * n + 1 if n % 2 else n // 2
        seq.append(n)
    return seq

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        lst.append(n)
    return lst

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = []
    while n > 1:
        result.append(n)
        n = n // 2 if n % 2 == 0 else n * 3 + 1
    result.append(1)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        if n == 2:
            n = 1
            sequence.append(n)
            break
        if n % 2 == 0:
            n = n // 2
            sequence.append(n)
        else:
            n = 3 * n + 1
            sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            n = n // 2 if n % 2 == 0 else n * 3 + 1
            result.append(n)
            if n == 1:
                break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            n = n // 2 if n % 2 == 0 else n * 3 + 1
            result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            if n % 2 == 0:
                n = n // 2
            else:
                n = n * 3 + 1
            result.append(n)
            if n == 1:
                break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [1]
    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = []
    while n > 1:
        lst.append(n)
        n = n // 2 if n % 2 == 0 else 3 * n + 1
    return lst + [1]

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    if n == 1:
        return [n]
    seq = [n]
    while n != 1:
        n = 3 * n + 1 if n % 2 else n // 2
        seq.append(n)
    return seq

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = n * 3 + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 10 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            n = n // 2 if n % 2 == 0 else n * 3 + 1
            result.append(n)
            if n == 1:
                break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            n = n // 2 if n % 2 == 0 else n * 3 + 1
            result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        if n == 2:
            n = 1
        elif n == 4:
            n = 2
        elif n == 8:
            n = 4
        elif n == 16:
            n = 8
        elif n == 32:
            n = 16
        elif n == 64:
            n = 32
        elif n == 128:
            n = 64
        elif n == 256:
            n = 128
        elif n == 512:
            n = 256
        elif n == 1024:
            n = 512
        elif n == 2048:
            n = 1024
        else:
            if n % 2 == 0:
                n = n // 2
            else:
                n = n * 3 + 1
            result.append(n)
            if n == 1:
                break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else n * 3 + 1
        result.append(n)
        if n == 1:
            break
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    seq = [n]
    while n != 1:
        n = 3 * n + 1 if n % 2 else n // 2
        seq.append(n)
    return seq

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    result = [n]
    while n > 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = n * 3 + 1
        result.append(n)
    return result

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    sequence = [n]
    while n > 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        sequence.append(n)
    return sequence

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which find the Collatz sequence for positive integer n. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'collatz' will take the argument 'n', an int > 0. It will return a list.
def collatz(n):

    lst = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        lst.append(n)
    return lst

def check(collatz):
    assert collatz(4) == [2, 1]
    assert collatz(41) == [124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(23) == [70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    assert collatz(4567) == [13702, 6851, 20554, 10277, 30832, 15416, 7708, 3854, 1927, 5782, 2891, 8674, 4337, 13012, 6506, 3253, 9760, 4880, 2440, 1220, 610, 305, 916, 458, 229, 688, 344, 172, 86, 43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

check(collatz)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        
        if str1[i] == str1[i - 1]:
            
            count += 1
        else:
            
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
Task 11 gens 3 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        
        if str1[i] == str1[i - 1]:
            
            count += 1
        else:
            
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
Task 11 gens 7 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 0:
        return ''
    elif len(str1) == 1:
        return str1
    else:
        count = 1
        compressed = ''
        for i in range(1, len(str1)):
            if str1[i] == str1[i - 1]:
                count += 1
            else:
                if count > 1:
                    compressed += str1[i - 1] + str(count)
                count = 1
        if count > 1:
            compressed += str1[-1] + str(count)
        return compressed

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        
        if str1[i] == str1[i - 1]:
            
            count += 1
        else:
            
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        
        if str1[i] == str1[i - 1]:
            
            count += 1
        else:
            
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
Task 11 gens 10 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 0:
        return ''
    elif len(str1) == 1:
        return str1
    else:
        count = 1
        compressed = ''
        for i in range(1, len(str1)):
            if str1[i] == str1[i - 1]:
                count += 1
            else:
                if count > 1:
                    compressed += str1[i - 1] + str(count)
                count = 1
        if count > 1:
            compressed += str1[-1] + str(count)
        return compressed

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    result = ""
    count = 0
    for c in s:
        if count == 0:
            result += c
            count += 1
        elif c == result[-1]:
            count += 1
        else:
            result += str(count) + result[-1]
            count = 1
            result += c
    if count > 1:
        result += str(count) + result[-1]
    return result[0] == s[0] and result or result[1:]

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: name 's' is not defined
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) > len(str1):
        return str1
    else:
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    c,count = '',0
    for i in s:
        if c == i: count += 1
        else:
            c,count = i,1
            if count == 1: continue
            if c + str(count) not in s[:s.index(i)]:
                s = s[:s.index(i)] + c + str(count) + s[s.index(i)+1:]
    return s

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: local variable 's' referenced before assignment
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ""
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 0
    for i in str1:
        count += 1
        if i != str1[count-2]:
            compressed_string += i
            compressed_string += str(count)
            count = 0
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        
        if str1[i] == str1[i - 1]:
            
            count += 1
        else:
            
            if count > 1:
                
                compressed_string += str1[i - 1] + str(count)
            
            count = 1
    if count > 1:
        
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: local variable 'count' referenced before assignment
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    import re
    s = re.sub(r'(.)\1+', r'\1\1', str1)
    return s

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) > len(str1):
        return str1
    else:
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) > len(str1):
        return str1
    else:
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 0
    for i in str1:
        count += 1
        if i != str1[count-2]:
            compressed_string += i
            compressed_string += str(count)
            count = 0
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    result = ""
    count = 0
    for c in str1:
        if count == 0:
            result += c
            count += 1
        elif c == result[-1]:
            count += 1
        else:
            result += str(count) + result[-1]
            count = 1
            result += c
    if count > 1:
        result += str(count) + result[-1]
    return result

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 0
    for i in str1:
        count += 1
        if i != str1[count-2]:
            compressed_string += i
            compressed_string += str(count)
            count = 0
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 == '':
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) > len(str1):
        return str1
    else:
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    result = ""
    count = 0
    for c in str1:
        if count == 0:
            result += c
            count += 1
        elif c == result[-1]:
            count += 1
        else:
            result += str(count) + result[-1]
            count = 1
            result += c
    if count > 1:
        result += str(count) + result[-1]
    return result

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    prev = None
    count = 1
    result = []
    for cur in str1:
        if cur == prev:
            count += 1
        else:
            if prev is not None:
                result.append(prev)
                result.append(str(count))
            count = 1
        prev = cur
    if prev is not None:
        result.append(prev)
        result.append(str(count))
    return ''.join(result)

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    for i in range(len(str1)):
        count = 1
        while i + count < len(str1):
            if str1[i] == str1[i + count]:
                count += 1
            else:
                break
        if count > 1:
            compressed_string += str1[i] + str(count)
            i += count - 1
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: local variable 'count' referenced before assignment
solution 9 passed False
Task 11 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    for i in range(len(str1)):
        count = 1
        while i + count < len(str1):
            if str1[i] == str1[i + count]:
                count += 1
            else:
                break
        if count > 1:
            compressed_string += str1[i] + str(count)
            i += count - 1
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    else:
        compressed_string = ''
        count = 1
        for i in range(1, len(str1)):
            if str1[i] == str1[i-1]:
                count += 1
                if count == len(str1):
                    compressed_string += str1[i-1] + str(count)
                    return compressed_string
            else:
                if count > 1:
                    compressed_string += str1[i-1] + str(count)
                    count = 1
                compressed_string += str1[i]
                if i == len(str1)-1:
                    compressed_string += str1[i] + str(count)
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 0:
        return ''
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: string index out of range
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ""
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 0
    for i in str1:
        count += 1
        if i != str1[count-2]:
            compressed_string += i
            compressed_string += str(count)
            count = 0
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    prev = None
    count = 1
    result = []
    for cur in str1:
        if cur == prev:
            count += 1
        else:
            if prev is not None:
                result.append(prev)
                result.append(str(count))
            count = 1
        prev = cur
    if prev is not None:
        result.append(prev)
        result.append(str(count))
    return ''.join(result)

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 0
    for i in str1:
        count += 1
        if i != str1[count-2]:
            compressed_string += i
            compressed_string += str(count)
            count = 0
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: string index out of range
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 == "":
        return str1
    count = 1
    compressed_string = ""
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 == '':
        return str1
    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    compressed = ""
    current_char = str1[0]
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == current_char:
            count += 1
        else:
            if count == 1:
                compressed += current_char
            elif count == 2:
                compressed += current_char + current_char
            else:
                compressed += current_char + str(count)
            current_char = str1[i]
            count = 1
    if count == 1:
        compressed += current_char
    elif count == 2:
        compressed += current_char + current_char
    else:
        compressed += current_char + str(count)
    return compressed

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    else:
        compressed_string = ''
        count = 1
        for i in range(1, len(str1)):
            if str1[i] == str1[i-1]:
                count += 1
                if count == len(str1):
                    compressed_string += str1[i-1] + str(count)
                    return compressed_string
            else:
                if count > 1:
                    compressed_string += str1[i-1] + str(count)
                    count = 1
                compressed_string += str1[i]
                if i == len(str1)-1:
                    compressed_string += str1[i] + str(count)
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 0
    for i in str1:
        count += 1
        if i != str1[count-2]:
            compressed_string += i
            compressed_string += str(count)
            count = 0
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 == '':
        return str1
    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: string index out of range
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 == "":
        return str1
    count = 1
    compressed_string = ""
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_string += str1[-1] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 0:
        return str1
    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    else:
        compressed_string = ''
        count = 1
        for i in range(1, len(str1)):
            if str1[i] == str1[i-1]:
                count += 1
                if count == len(str1):
                    compressed_string += str1[i-1] + str(count)
                    return compressed_string
            else:
                if count > 1:
                    compressed_string += str1[i-1] + str(count)
                    count = 1
                compressed_string += str1[i]
                if i == len(str1)-1:
                    compressed_string += str1[i] + str(count)
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    import re
    if str1 == '':
        return ''
    prev = str1[0]
    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed = ""
    current_char = str1[0]
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == current_char:
            count += 1
        else:
            if count == 1:
                compressed += current_char
            elif count == 2:
                compressed += current_char + current_char
            else:
                compressed += current_char + str(count)
            current_char = str1[i]
            count = 1
    if count == 1:
        compressed += current_char
    elif count == 2:
        compressed += current_char + current_char
    else:
        compressed += current_char + str(count)
    return compressed

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    else:
        compressed_string = ''
        count = 1
        for i in range(1, len(str1)):
            if str1[i] == str1[i-1]:
                count += 1
                if count == len(str1):
                    compressed_string += str1[i-1] + str(count)
                    return compressed_string
            else:
                if count > 1:
                    compressed_string += str1[i-1] + str(count)
                    count = 1
                compressed_string += str1[i]
                if i == len(str1)-1:
                    compressed_string += str1[i] + str(count)
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ""
    if str1 == "":
        return compressed_string
    count = 1
    for i in range(len(str1)):
        if i == len(str1) - 1:
            if count > 1:
                compressed_string += str1[i] + str(count)
            break
        if str1[i] == str1[i + 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i] + str(count)
            count = 1
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    else:
        compressed_string = ''
        count = 1
        for i in range(1, len(str1)):
            if str1[i] == str1[i - 1]:
                count += 1
                if count == len(str1):
                    compressed_string += str1[i - 1] + str(count)
            else:
                if count > 1:
                    compressed_string += str1[i - 1] + str(count)
                compressed_string += str1[i]
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 is None or len(str1) <= 1:
        return str1
    compressed_str = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_str += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_str += str1[-1] + str(count)
    return compressed_str

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i - 1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(s) == 0:
        return s
    compressed_string = ''
    count = 1
    prev = s[0]
    for i in range(1, len(s)):
        if s[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = s[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: name 's' is not defined
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
                count = 1
            compressed_string += str1[i]
    if count > 1:
        compressed_string += str1[-1] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
                return compressed_string
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
                count = 1
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 11 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 0:
        return ''
    compressed_string = ''
    count = 1
    prev = str1[0]
    for i in range(1, len(str1)):
        if str1[i] == prev:
            count += 1
        else:
            if count == 1:
                compressed_string += prev
            elif count > 1:
                compressed_string += prev + str(count)
            prev = str1[i]
            count = 1
    if count == 1:
        compressed_string += prev
    elif count > 1:
        compressed_string += prev + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : passed
solution 0 passed True
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ""
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i - 1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    if len(compressed_string) >= len(str1):
        return str1
    else:
        return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    else:
        return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if str1 == "":
        return compressed_string
    else:
        compressed_string = ""
        count = 1
        for i in range(len(str1)):
            if i == len(str1) - 1:
                if count > 1:
                    compressed_string += str1[i] + str(count)
                break
            if str1[i] == str1[i + 1]:
                count += 1
            else:
                if count > 1:
                    compressed_string += str1[i] + str(count)
                count = 1
        if len(compressed_string) < len(str1):
            return compressed_string
        else:
            return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) == 1:
        return str1
    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i-1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i-1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    compressed_string = ''
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
                count = 1
            compressed_string += str1[i]
    if count > 1:
        compressed_string += str1[i] + str(count)
    return compressed_string

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i - 1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    if len(str1) < 2:
        return str1
    count = 1
    compressed_string = ''
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
            if count == len(str1):
                compressed_string += str1[i - 1] + str(count)
        else:
            if count > 1:
                compressed_string += str1[i - 1] + str(count)
            compressed_string += str1[i]
            if i == len(str1) - 1:
                compressed_string += str1[i] + str(count)
    if len(compressed_string) < len(str1):
        return compressed_string
    return str1

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which compresses a string such that 'AAABCCDDDD' becomes 'A3BC2D4'. Only compresses the string if it saves space. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'compress_string' will take the argument 'str1', a string. It will return a compressed string.
def compress_string(str1):

    import re
    if str1 is None or len(str1) <= 1:
        return str1
    compressed_str = ""
    count = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i - 1]:
            count += 1
        else:
            if count > 1:
                compressed_str += str1[i - 1] + str(count)
            count = 1
    if count > 1:
        compressed_str += str1[-1] + str(count)
    return compressed_str

def check(compress_string):
    assert compress_string('AAABCCDDDD') == 'A3BC2D4'
    assert compress_string('ABC') == 'ABC'
    assert compress_string('dfddddhhkdkkk') == 'dfd4h2kdk3'
    assert compress_string('') == ''
    assert compress_string('abbbbbbbb') == 'ab8'

check(compress_string)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
Task 12 gens 2 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
Task 12 gens 4 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
Task 12 gens 7 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import unittest
    morse_code_dict = {'.-': 'a', '-...': 'b', '-.-.': 'c', '-..': 'd', '.': 'e', '..-.': 'f',
        '--.': 'g', '....': 'h', '..': 'i', '.---': 'j', '-.-': 'k', '.-..': 'l',
        '--': 'm', '-.': 'n', '---': 'o', '.--.': 'p', '--.-': 'q', '.-.': 'r',
        '...': 's', '-': 't', '..-': 'u', '...-': 'v', '.--': 'w', '-..-': 'x',
        '-.--': 'y', '--..': 'z', '.----': '1', '..---': '2', '...--': '3',
        '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',
        '----.': '9', '-----': '0', '--..--': ', ', '.-.-.-': '.',
        '..--..': '?', '-..-.': '/', '-....-': '-', '-.--.': '(', '-.--.-': ')'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code
    def test_encode_morse(self):
        self.assertEqual(encode_morse(''), '')
        self.assertEqual(encode_morse('a'), '.----')
        self.assertEqual(encode_morse('b'), '--.-.')
        self.assertEqual(encode_morse('c'), '-.-.')
        self.assertEqual(encode_morse('d'), '-..')
        self.assertEqual(encode_morse('e'), '.')

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
Task 12 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import unittest
    morse_code_dict = {'.-': 'a', '-...': 'b', '-.-.': 'c', '-..': 'd', '.': 'e', '..-.': 'f',
        '--.': 'g', '....': 'h', '..': 'i', '.---': 'j', '-.-': 'k', '.-..': 'l',
        '--': 'm', '-.': 'n', '---': 'o', '.--.': 'p', '--.-': 'q', '.-.': 'r',
        '...': 's', '-': 't', '..-': 'u', '...-': 'v', '.--': 'w', '-..-': 'x',
        '-.--': 'y', '--..': 'z', '.----': '1', '..---': '2', '...--': '3',
        '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',
        '----.': '9', '-----': '0', '--..--': ', ', '.-.-.-': '.',
        '..--..': '?', '-..-.': '/', '-....-': '-', '-.--.': '(', '-.--.-': ')'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code
    def test_encode_morse(self):
        self.assertEqual(encode_morse(''), '')
        self.assertEqual(encode_morse('a'), '.----')
        self.assertEqual(encode_morse('b'), '--.-.')
        self.assertEqual(encode_morse('c'), '-.-.')
        self.assertEqual(encode_morse('d'), '-..')
        self.assertEqual(encode_morse('e'), '.')

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import unittest
    morse_code_dict = {'.-': 'a', '-...': 'b', '-.-.': 'c', '-..': 'd', '.': 'e', '..-.': 'f',
        '--.': 'g', '....': 'h', '..': 'i', '.---': 'j', '-.-': 'k', '.-..': 'l',
        '--': 'm', '-.': 'n', '---': 'o', '.--.': 'p', '--.-': 'q', '.-.': 'r',
        '...': 's', '-': 't', '..-': 'u', '...-': 'v', '.--': 'w', '-..-': 'x',
        '-.--': 'y', '--..': 'z', '.----': '1', '..---': '2', '...--': '3',
        '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',
        '----.': '9', '-----': '0', '--..--': ', ', '.-.-.-': '.',
        '..--..': '?', '-..-.': '/', '-....-': '-', '-.--.': '(', '-.--.-': ')'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code
    def test_encode_morse(self):
        self.assertEqual(encode_morse(''), '')
        self.assertEqual(encode_morse('a'), '.----')
        self.assertEqual(encode_morse('b'), '--.-.')
        self.assertEqual(encode_morse('c'), '-.-.')
        self.assertEqual(encode_morse('d'), '-..')
        self.assertEqual(encode_morse('e'), '.')
    unittest.main()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    d = d.lower()
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import unittest
    morse_code_dict = {'.-': 'a', '-...': 'b', '-.-.': 'c', '-..': 'd', '.': 'e', '..-.': 'f',
        '--.': 'g', '....': 'h', '..': 'i', '.---': 'j', '-.-': 'k', '.-..': 'l',
        '--': 'm', '-.': 'n', '---': 'o', '.--.': 'p', '--.-': 'q', '.-.': 'r',
        '...': 's', '-': 't', '..-': 'u', '...-': 'v', '.--': 'w', '-..-': 'x',
        '-.--': 'y', '--..': 'z', '.----': '1', '..---': '2', '...--': '3',
        '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',
        '----.': '9', '-----': '0', '--..--': ', ', '.-.-.-': '.',
        '..--..': '?', '-..-.': '/', '-....-': '-', '-.--.': '(', '-.--.-': ')'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code
    def test_encode_morse(self):
        self.assertEqual(encode_morse(''), '')
        self.assertEqual(encode_morse('a'), '.----')
        self.assertEqual(encode_morse('b'), '--.-.')
        self.assertEqual(encode_morse('c'), '-.-.')
        self.assertEqual(encode_morse('d'), '-..')
        self.assertEqual(encode_morse('e'), '.')

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    d = d.lower()
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d.lower():
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d.lower():
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    d = d.lower()
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
                        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
                        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
                        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
                        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
                        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
                        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
                        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
                        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
                        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
                        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
                        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
                        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
                        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
                        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d.lower():
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    d = d.lower()
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
                        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
                        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
                        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
                        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
                        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
                        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
                        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    d = d.lower()
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import string
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
                        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
                        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
                        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
                        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
                        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
                        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
                        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d.lower():
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 12 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    d = d.lower()
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    import re
    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.strip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
        'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
        '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = {
    'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
    'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
    'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
    's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
    'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
    '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
    '9':'----.', '0':'-----', ', ':'--..--', '.':'.-.-.-',
    '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d.lower():
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which encodes a string to morse code. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'encode_morse' will take the argument 'd', a string. It will return a string of morse code.
def encode_morse(d):

    morse_code_dict = { 'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.',
                        'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..',
                        'm':'--', 'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.',
                        's':'...', 't':'-', 'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-',
                        'y':'-.--', 'z':'--..', '1':'.----', '2':'..---', '3':'...--',
                        '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..',
                        '9':'----.', '0':'-----', ',':'--..--', '.':'.-.-.-',
                        '?':'..--..', '/':'-..-.', '-':'-....-', '(':'-.--.', ')':'-.--.-'}
    morse_code = ''
    for char in d:
        if char in morse_code_dict:
            morse_code += morse_code_dict[char] + ' '
        else:
            morse_code += char
    return morse_code.rstrip()

def check(encode_morse):
    assert encode_morse('Hello') == '.... . .-.. .-.. ---'
    assert encode_morse('my Name') == '-- -.--   -. .- -- .'
    assert encode_morse('jiggerypokery') == '.--- .. --. --. . .-. -.-- .--. --- -.- . .-. -.--'
    assert encode_morse("what's this") == '.-- .... .- - .----. ...   - .... .. ...'

check(encode_morse)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += 'FizzBuzz\n'
        elif i % 3 == 0:
            result += 'Fizz\n'
        elif i % 5 == 0:
            result += 'Buzz\n'
        else:
            result += str(i) + '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
Task 13 gens 4 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join([str(i) if (i % 3 != 0 and i % 5 != 0) else 'Fizz' if i % 3 == 0 else 'Buzz' for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            lines.append('FizzBuzz')
        elif i % 3 == 0:
            lines.append('Fizz')
        elif i % 5 == 0:
            lines.append('Buzz')
        else:
            lines.append(str(i))
    return '\n'.join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += 'FizzBuzz\n'
        elif i % 3 == 0:
            result += 'Fizz\n'
        elif i % 5 == 0:
            result += 'Buzz\n'
        else:
            result += str(i) + '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join([str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 and i % 5 != 0 else 'Buzz' if i % 3 != 0 and i % 5 == 0 else 'FizzBuzz' for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
Task 13 gens 10 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    out = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            out += 'FizzBuzz\n'
        elif i % 3 == 0:
            out += 'Fizz\n'
        elif i % 5 == 0:
            out += 'Buzz\n'
        else:
            out += str(i) + '\n'
    return out

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ""
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += "FizzBuzz\n"
        elif i % 3 == 0:
            result += "Fizz\n"
        elif i % 5 == 0:
            result += "Buzz\n"
        else:
            result += str(i) + "\n"
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join([str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 and i % 5 != 0 else 'Buzz' if i % 3 != 0 and i % 5 == 0 else 'FizzBuzz' for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        line = ''
        if i % 3 == 0 and i % 5 == 0:
            line += 'FizzBuzz'
        elif i % 3 == 0:
            line += 'Fizz'
        elif i % 5 == 0:
            line += 'Buzz'
        else:
            line += str(i)
        lines.append(line)
    return '\n'.join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        line = ''
        if i % 3 == 0:
            line += 'Fizz'
        if i % 5 == 0:
            line += 'Buzz'
        if line == '':
            line += str(i)
        lines.append(line)
    return '\n'.join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            lines.append("FizzBuzz")
        elif i % 3 == 0:
            lines.append("Fizz")
        elif i % 5 == 0:
            lines.append("Buzz")
        else:
            lines.append(str(i))
    return "\n".join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n < 0:
        raise ValueError("n should be non-negative")
    return "\n".join([
        "FizzBuzz" if i % 3 == 0 and i % 5 == 0 else
        "Fizz" if i % 3 == 0 else
        "Buzz" if i % 5 == 0 else
        str(i)
        for i in range(n)
    ])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    mylist = []
    for i in range(n):
        if i % 3 != 0 and i % 5 != 0:
            mylist.append(str(i))
        elif i % 3 == 0 and i % 5 != 0:
            mylist.append('Fizz')
        elif i % 3 != 0 and i % 5 == 0:
            mylist.append('Buzz')
        else:
            mylist.append('FizzBuzz')
    return '\n'.join(mylist)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result = result + 'FizzBuzz\n'
        elif i % 3 == 0:
            result = result + 'Fizz\n'
        elif i % 5 == 0:
            result = result + 'Buzz\n'
        else:
            result = result + str(i) + '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    ret = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            ret += 'FizzBuzz\n'
        elif i % 3 == 0:
            ret += 'Fizz\n'
        elif i % 5 == 0:
            ret += 'Buzz\n'
        else:
            ret += str(i) + '\n'
    return ret.rstrip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join([('Fizz' if i % 3 == 0 else '') +
                      ('Buzz' if i % 5 == 0 else str(i))
                      for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    mylist = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            mylist.append('FizzBuzz')
        elif i % 3 == 0:
            mylist.append('Fizz')
        elif i % 5 == 0:
            mylist.append('Buzz')
        else:
            mylist.append(str(i))
    return '\n'.join(mylist)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    s = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            s += 'FizzBuzz\n'
        elif i % 3 == 0:
            s += 'Fizz\n'
        elif i % 5 == 0:
            s += 'Buzz\n'
        else:
            s += str(i) + '\n'
    return s

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        line = ''
        if i % 3 == 0 and i % 5 == 0:
            line += 'FizzBuzz'
        elif i % 3 == 0:
            line += 'Fizz'
        elif i % 5 == 0:
            line += 'Buzz'
        else:
            line += str(i)
        lines.append(line)
    return '\n'.join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        result += str(i) + '\n'
        if (i % 3) == 0:
            result += 'Fizz'
        if (i % 5) == 0:
            result += 'Buzz'
        result += '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ""
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += "FizzBuzz\n"
        elif i % 3 == 0:
            result += "Fizz\n"
        elif i % 5 == 0:
            result += "Buzz\n"
        else:
            result += str(i) + "\n"
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join([str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 and i % 5 != 0 else 'Buzz' if i % 3 != 0 and i % 5 == 0 else 'FizzBuzz' for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    mylist = []
    for i in range(n):
        if i % 3 != 0 and i % 5 != 0:
            mylist.append(str(i))
        elif i % 3 == 0 and i % 5 != 0:
            mylist.append('Fizz')
        elif i % 3 != 0 and i % 5 == 0:
            mylist.append('Buzz')
        else:
            mylist.append('FizzBuzz')
    return '\n'.join(mylist)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join(str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 else 'Buzz' for i in range(n))

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    mylist = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            mylist.append('FizzBuzz')
        elif i % 3 == 0:
            mylist.append('Fizz')
        elif i % 5 == 0:
            mylist.append('Buzz')
        else:
            mylist.append(str(i))
    return '\n'.join(mylist)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return "\n".join(
        "FizzBuzz" if i % 3 == 0 and i % 5 == 0
        else "Fizz" if i % 3 == 0 else "Buzz" if i % 5 == 0
        else str(i)
        for i in range(n)
    )

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            lines.append("FizzBuzz")
        elif i % 3 == 0:
            lines.append("Fizz")
        elif i % 5 == 0:
            lines.append("Buzz")
        else:
            lines.append(str(i))
    return '\n'.join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    s = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            s += 'FizzBuzz\n'
        elif i % 3 == 0:
            s += 'Fizz\n'
        elif i % 5 == 0:
            s += 'Buzz\n'
        else:
            s += str(i) + '\n'
    return s

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return ('\n'.join([str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 else 'Buzz' for i in range(n)]))

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join(str(i) if i%3!=0 and i%5!=0 else 'Fizz' if i%3==0 and i%5!=0 else 'Buzz' if i%3!=0 and i%5==0 else 'FizzBuzz' for i in range(n))

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        result += str(i) + '\n'
        if (i % 3) == 0:
            result += 'Fizz'
        if (i % 5) == 0:
            result += 'Buzz'
        if ((i % 3) == 0) and ((i % 5) == 0):
            result += 'FizzBuzz'
        result += '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ""
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += "FizzBuzz\n"
        elif i % 3 == 0:
            result += "Fizz\n"
        elif i % 5 == 0:
            result += "Buzz\n"
        else:
            result += str(i) + "\n"
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result = f'{result}FizzBuzz\n'
        elif i % 3 == 0:
            result = f'{result}Fizz\n'
        elif i % 5 == 0:
            result = f'{result}Buzz\n'
        else:
            result = f'{result}{i}\n'
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return "\n".join(
        "FizzBuzz" if i % 3 == 0 and i % 5 == 0
        else "Fizz" if i % 3 == 0 else "Buzz" if i % 5 == 0
        else str(i)
        for i in range(n)
    )

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    s = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            s += 'FizzBuzz\n'
        elif i % 3 == 0:
            s += 'Fizz\n'
        elif i % 5 == 0:
            s += 'Buzz\n'
        else:
            s += str(i) + '\n'
    return s

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join(str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 and i % 5 != 0 else 'Buzz' if i % 3 != 0 and i % 5 == 0 else 'FizzBuzz' for i in range(n))

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if (i % 3 == 0) and (i % 5 == 0):
            result = f'{result}FizzBuzz\n'
        elif i % 3 == 0:
            result = f'{result}Fizz\n'
        elif i % 5 == 0:
            result = f'{result}Buzz\n'
        else:
            result = f'{result}{i}\n'
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return ('\n'.join([str(i) if i % 3 != 0 and i % 5 != 0 else 'Fizz' if i % 3 == 0 else 'Buzz' for i in range(n)]))

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ""
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result = result + "FizzBuzz\n"
        elif i % 3 == 0:
            result = result + "Fizz\n"
        elif i % 5 == 0:
            result = result + "Buzz\n"
        else:
            result = result + str(i) + "\n"
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = []
    for i in range(n):
        if i%3==0 and i%5==0:
            result.append('FizzBuzz')
        elif i%3==0:
            result.append('Fizz')
        elif i%5==0:
            result.append('Buzz')
        else:
            result.append(str(i))
    return '\n'.join(result)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if (i % 3 == 0) and (i % 5 == 0):
            result = f'{result}FizzBuzz\n'
        elif i % 3 == 0:
            result = f'{result}Fizz\n'
        elif i % 5 == 0:
            result = f'{result}Buzz\n'
        else:
            result = f'{result}{i}\n'
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ""
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += "FizzBuzz\n"
        elif i % 3 == 0:
            result += "Fizz\n"
        elif i % 5 == 0:
            result += "Buzz\n"
        else:
            result += f"{i}\n"
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        result += str(i) + '\n'
        if i % 3 == 0:
            result += 'Fizz'
        if i % 5 == 0:
            result += 'Buzz'
        if i % 3 == 0 and i % 5 == 0:
            result += 'FizzBuzz'
        result += '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        result += str(i) + '\n'
        if i % 3 == 0 and i % 5 == 0:
            result += "FizzBuzz\n"
        elif i % 3 == 0:
            result += "Fizz\n"
        elif i % 5 == 0:
            result += "Buzz\n"
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += 'FizzBuzz\n'
        elif i % 3 == 0:
            result += 'Fizz\n'
        elif i % 5 == 0:
            result += 'Buzz\n'
        else:
            result += str(i) + '\n'
    return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    lines = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            lines.append("FizzBuzz")
        elif i % 3 == 0:
            lines.append("Fizz")
        elif i % 5 == 0:
            lines.append("Buzz")
        else:
            lines.append(str(i))
    return '\n'.join(lines)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(1,n+1):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = ''
    for i in range(n):
        result += str(i) + '\n'
        if i % 3 == 0 and i % 5 == 0:
            result += 'FizzBuzz'
        elif i % 3 == 0:
            result += 'Fizz'
        elif i % 5 == 0:
            result += 'Buzz'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    result = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result.append("FizzBuzz")
        elif i % 3 == 0:
            result.append("Fizz")
        elif i % 5 == 0:
            result.append("Buzz")
        else:
            result.append(str(i))
    return "\n".join(result)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz\n')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz\n')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz\n')
        else:
            fizzbuzz_list.append(str(i) + '\n')
    return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(1,n+1):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        result = ''
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                result += 'FizzBuzz\n'
            elif i % 3 == 0:
                result += 'Fizz\n'
            elif i % 5 == 0:
                result += 'Buzz\n'
            else:
                result += f'{i}\n'
        return result.strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    return "\n".join([fizzbuzz(i) if i in [3,5,15] else fizzbuzz(i) if i%3 == 0 else fizzbuzz(i) if i%5 == 0 else str(i) for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join(map(str, range(n)))
    if i % 3 == 0 and i % 5 == 0:
        fizzbuzz_list.append('FizzBuzz')
    elif i % 3 == 0:
        fizzbuzz_list.append('Fizz')
    elif i % 5 == 0:
        fizzbuzz_list.append('Buzz')
    else:
        fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz\n')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz\n')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz\n')
        else:
            fizzbuzz_list.append(str(i) + '\n')
    return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    return "\n".join([fizzbuzz(i) if i in [3,5,15] else fizzbuzz(i) if i%3 == 0 else fizzbuzz(i) if i%5 == 0 else str(i) for i in range(n)])

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0\n'
    result = []
    for i in range(1,n+1):
        if i % 3 == 0 and i % 5 == 0:
            result.append('FizzBuzz')
        elif i % 3 == 0:
            result.append('Fizz')
        elif i % 5 == 0:
            result.append('Buzz')
        else:
            result.append(str(i))
    return '\n'.join(result)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    fizzbuzz_list = []
    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 13 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join(map(str, range(n)))
    if i % 3 == 0 and i % 5 == 0:
        fizzbuzz_list.append('FizzBuzz')
    elif i % 3 == 0:
        fizzbuzz_list.append('Fizz')
    elif i % 5 == 0:
        fizzbuzz_list.append('Buzz')
    else:
        fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    return '\n'.join(map(str, range(n)))

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        result = ''
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                result += 'FizzBuzz\n'
            elif i % 3 == 0:
                result += 'Fizz\n'
            elif i % 5 == 0:
                result += 'Buzz\n'
            else:
                result += str(i) + '\n'
        return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    fizzbuzz_list = []
    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list).strip()

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0\n'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    fizzbuzz_list = []
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            fizzbuzz_list.append('FizzBuzz')
        elif i % 3 == 0:
            fizzbuzz_list.append('Fizz')
        elif i % 5 == 0:
            fizzbuzz_list.append('Buzz')
        else:
            fizzbuzz_list.append(str(i))
    return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz')
            else:
                fizzbuzz_list.append(str(i))
        return '\n'.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    elif n == 1:
        return '0\n'
    else:
        fizzbuzz_list = []
        for i in range(n):
            if i % 3 == 0 and i % 5 == 0:
                fizzbuzz_list.append('FizzBuzz\n')
            elif i % 3 == 0:
                fizzbuzz_list.append('Fizz\n')
            elif i % 5 == 0:
                fizzbuzz_list.append('Buzz\n')
            else:
                fizzbuzz_list.append(str(i) + '\n')
        return ''.join(fizzbuzz_list)

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which returns a string with n lines. Index starts at zero. Each line contains its index number, or Fizz if i % 3 == 0, or Buzz if i % 5 == 0 , or FizzBuzz if i % 3 == 0 and i % 5 == 0. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'fizzbuzz' will take the argument 'n', an i. It will return a multi-line string.
def fizzbuzz(n):

    if n == 0:
        return ''
    if n == 1:
        return '0'
    result = ''
    for i in range(n):
        if i % 3 == 0 and i % 5 == 0:
            result += 'FizzBuzz\n'
        elif i % 3 == 0:
            result += 'Fizz\n'
        elif i % 5 == 0:
            result += 'Buzz\n'
        else:
            result += str(i) + '\n'
    return result

def check(fizzbuzz):
    assert fizzbuzz(1) == 'FizzBuzz'
    assert fizzbuzz(5) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    assert fizzbuzz(16) == 'FizzBuzz'
    '1'
    '2'
    'Fizz'
    '4'
    'Buzz'
    'Fizz'
    '7'
    '8'
    'Fizz'
    'Buzz'
    '11'
    'Fizz'
    '13'
    '14'
    'FizzBuzz'

check(fizzbuzz)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return str1 + str2 + interlace_strings(str2, str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: maximum recursion depth exceeded
solution 0 passed False
Task 14 gens 6 solutions in cir 1
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    for i in range(len(max(str1, str2))):
        if i < len(str1):
            result += str1[i]
        if i < len(str2):
            result += str2[i]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    elif len(str2) == 0:
        return str1
    else:
        return str1 + str2[0] + interlace_strings(str2, str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0: return str2
    if len(str2) == 0: return str1
    return str1[0] + interlace_strings(str2, str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return str1 + str2 + interlace_strings(str2, str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: maximum recursion depth exceeded
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    for i in range(len(str1)):
        result += str1[i]
        result += str2[i]
    result += str1[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1)==1:
        return str1+str2
    else:
        return str1 + interlace_strings(str2,str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
Task 14 gens 10 solutions in cir 2
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if not str1: return str2
    if not str2: return str1
    result = ""
    for i in range(min(len(str1), len(str2))):
        result += str1[i] + str2[i]
    if len(str1) > len(str2):
        result += str1[len(str2):]
    elif len(str2) > len(str1):
        result += str2[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 1 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    while len(str1) > 0 and len(str2) > 0:
        result += str1[0]
        result += str2[0]
        str1 = str1[1:]
        str2 = str2[1:]
    result += str1
    result += str2
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    for i in range(len(max(str1, str2))):
        if i < len(str1):
            result += str1[i]
        if i < len(str2):
            result += str2[i]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    for i in range(min(len(str1), len(str2))):
        result += str1[i]
        result += str2[i]
    if len(str1) > len(str2):
        result += str1[len(str2):]
    elif len(str1) < len(str2):
        result += str2[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0: return str2
    if len(str2) == 0: return str1
    return str1[0] + interlace_strings(str2, str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    else:
        return str1[0] + interlace_strings(str2, str1[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    str = ""
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            str += str1[i]
        if i < len(str2):
            str += str2[i]
    return str

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 7 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    i = 0
    j = 0
    while i < len(str1) and j < len(str2):
        result += str1[i] + str2[j]
        i += 1
        j += 1
    if i < len(str1):
        result += str1[i:]
    elif j < len(str2):
        result += str2[j:]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if str1 == "":
        return str2
    if str2 == "":
        return str1
    result = ""
    for i in range(0, len(str1)):
        result += str1[i]
        result += str2[i]
    result += str1[len(str1)-1]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 10 solutions in cir 3
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
        i += 1
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    i = 0
    j = 0
    while i < len(str1) and j < len(str2):
        result += str1[i] + str2[j]
        i += 1
        j += 1
    while i < len(str1):
        result += str1[i]
        i += 1
    while j < len(str2):
        result += str2[j]
        j += 1
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 2 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    elif len(str2) == 0:
        return str1
    else:
        return str1[0] + str2[0] + interlace_strings(str1[1:], str2[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    for i in range(min(len(str1), len(str2))):
        result += str1[i] + str2[i]
    if len(str1) > len(str2):
        result += str1[len(str2):]
    elif len(str2) > len(str1):
        result += str2[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    i = 0
    while i < min(len(str1), len(str2)):
        result += str1[i] + str2[i]
        i += 1
    if len(str1) > len(str2):
        result += str1[i:]
    elif len(str2) > len(str1):
        result += str2[i:]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if (len(str1) == 0) or (len(str2) == 0):
        return str1 + str2
    result = ""
    for i in range(min(len(str1), len(str2))):
        result += str1[i] + str2[i]
    result += str1[len(str2):] + str2[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if str1 == "":
        return str2
    if str2 == "":
        return str1
    result = ""
    for i in range(0, len(str1)):
        result += str1[i]
        result += str2[i]
    result += str1[len(str1)-1]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    i = 0
    while i < len(max(str1, str2)):
        result += str1[i] if i < len(str1) else ""
        result += str2[i] if i < len(str2) else ""
        i += 1
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    i = 0
    result = ''
    while i < min(len(str1), len(str2)):
        result += str1[i]
        result += str2[i]
        i += 1
    if len(str1) > len(str2):
        result += str1[i:]
    elif len(str1) < len(str2):
        result += str2[i:]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 9 passed True
Task 14 gens 10 solutions in cir 4
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
        i += 1
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0, len(max(str1, str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    if len(str1) == 0:
        return str2
    elif len(str2) == 0:
        return str1
    else:
        for i in range(min(len(str1), len(str2))):
            result += str1[i] + str2[i]
        if len(str1) > len(str2):
            result += str1[len(str2):]
        elif len(str2) > len(str1):
            result += str2[len(str1):]
        return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 3 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    i = 0
    j = 0
    while i < len(str1) and j < len(str2):
        result += str1[i] + str2[j]
        i += 1
        j += 1
    while i < len(str1):
        result += str1[i]
        i += 1
    while j < len(str2):
        result += str2[j]
        j += 1
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 4 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    while len(str1) > 0 and len(str2) > 0:
        result = result + str1[0]
        result = result + str2[0]
        str1 = str1[1:]
        str2 = str2[1:]
    result = result + str1 + str2
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 5 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    if len(str2) == 0:
        return str1
    return str1[0] + str2[0] + interlace_strings(str1[1:], str2[1:])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if str1 == "":
        return str2
    if str2 == "":
        return str1
    result = ""
    for i in range(0, len(str1)):
        result += str1[i]
        result += str2[i]
    result += str1[len(str1)-1]
    result += str2[len(str2)-1]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ''
    for i in range(min(len(str1), len(str2))):
        result += str1[i]
        result += str2[i]
    if len(str1) > len(str2):
        result += str1[len(str2):]
    elif len(str1) < len(str2):
        result += str2[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if (len(str1) == 0) or (len(str2) == 0):
        return str1 + str2
    result = ""
    for i in range(min(len(str1), len(str2))):
        result += str1[i] + str2[i]
    result += str1[len(str2):] + str2[len(str1):]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 9 passed True
Task 14 gens 10 solutions in cir 5
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0, len(max(str1, str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ''
    b = ''
    for i in range(len(max(str1, str2))):
        if len(str1) - 1 >= i:
            a += str1[i]
        if len(str2) - 1 >= i:
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0, len(max(str1, str2))):
        if i < len(str1):
            a = a + str1[i]
        if i < len(str2):
            b = b + str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
        i += 1
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) > len(str2):
        return interlace_strings(str2, str1)
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    while len(str1) > 0 and len(str2) > 0:
        result += str1[0] + str2[0]
        str1 = str1[1:]
        str2 = str2[1:]
    if len(str1) > 0:
        result += str1
    elif len(str2) > 0:
        result += str2
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 6 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if str1 == "":
        return str2
    if str2 == "":
        return str1
    result = ""
    for i in range(0, len(str1)):
        result += str1[i]
        result += str2[i]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    result = ""
    len1 = len(str1)
    len2 = len(str2)
    min_len = min(len1, len2)
    for i in range(min_len):
        result += str1[i]
        result += str2[i]
    if len1 > len2:
        result += str1[len2:]
    if len2 > len1:
        result += str2[len1:]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : passed
solution 8 passed True
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if str1 == "":
        return str2
    if str2 == "":
        return str1
    result = ""
    for i in range(0, len(str1)):
        result += str1[i]
        result += str2[i]
    result += str1[len(str1)-1]
    result += str2[len(str2)-1]
    return result

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 10 solutions in cir 6
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) > len(str2):
        return interlace_strings(str2, str1)
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) > len(str2):
        return interlace_strings(str2, str1)
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1, str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = []
    b = []
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a.append(str1[i])
        if i < len(str2):
            b.append(str2[i])
        i += 1
    return ''.join(a)+''.join(b)

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0, len(max(str1, str2))):
        if i < len(str1):
            a = a + str1[i]
        if i < len(str2):
            b = b + str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
        i += 1
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    if len(str2) == 0:
        return str1
    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ''
    b = ''
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 10 solutions in cir 7
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) > len(str2):
        return interlace_strings(str2, str1)
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return ''.join([*str1,*str2])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1, str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) > len(str2):
        return interlace_strings(str2, str1)
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = []
    b = []
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a.append(str1[i])
        if i < len(str2):
            b.append(str2[i])
        i += 1
    return ''.join(a)+''.join(b)

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    if len(str2) == 0:
        return str1
    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    i = 0
    while i < len(max(str1, str2)):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
        i += 1
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 10 solutions in cir 8
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return ''.join([*str1, *str2])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) > len(str2):
        return interlace_strings(str2, str1)
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b
    a = ""
    b = ""
    for i in range(len(str1)):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(a) < len(str1):
        a += str1[len(a):]
    if len(b) < len(str2):
        b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return str1 + ''.join(str2[i] for i in range(len(str1)) if i < len(str2)) + str2[len(str1):]

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if len(str1) == 0:
        return str2
    if len(str2) == 0:
        return str1
    a = ""
    b = ""
    for i in range(0,len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b
    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1, str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        a += str1[i % len(str1)] if i < len(str1) else ""
        b += str2[i % len(str2)] if i < len(str2) else ""
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 10 solutions in cir 9
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        a += str1[i % len(str1)] if i < len(str1) else ""
        b += str2[i % len(str2)] if i < len(str2) else ""
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    a += str1[len(a):]
    b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b
    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if (len(str1) == 0) or (len(str2) == 0):
        return str1 + str2
    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ''
    b = ''
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    if len(str1) == 0:
        return str2
    elif len(str2) == 0:
        return str1
    else:
        for i in range(len(max(str1, str2))):
            if i < len(str1):
                a += str1[i]
            if i < len(str2):
                b += str2[i]
        return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return "".join(char for char in str1 + str2)

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(min(len(str1),len(str2))):
        a += str1[i]
        if i < len(str2):
            b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(b):]
    if len(str2) > len(str1):
        b += str2[len(a):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 14 gens 10 solutions in cir 10
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    if len(str1) == 0:
        return str2
    elif len(str2) == 0:
        return str1
    else:
        for i in range(len(max(str1, str2))):
            if i < len(str1):
                a += str1[i]
            if i < len(str2):
                b += str2[i]
        return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 0 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    a += str1[len(a):]
    b += str2[len(b):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 1 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 2 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        if i < len(str1):
            a += str1[i]
        if i < len(str2):
            b += str2[i]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 3 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b
    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 4 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(max(len(str1), len(str2))):
        a += str1[i % len(str1)] if i < len(str1) else ""
        b += str2[i % len(str2)] if i < len(str2) else ""
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 5 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    if (len(str1) == 0) or (len(str2) == 0):
        return str1 + str2
    a = ""
    b = ""
    for i in range(min(len(str1), len(str2))):
        a += str1[i]
        b += str2[i]
    if len(str1) > len(str2):
        a += str1[len(str2):]
    if len(str2) > len(str1):
        b += str2[len(str1):]
    return a + b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 6 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return "".join([str1[i % len(str1)] if i < len(str1) else "" for i in range(max(len(str1), len(str2)))] + [str2[i % len(str2)] if i < len(str2) else "" for i in range(max(len(str1), len(str2)))])

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 7 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    return str1 + str2

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 8 passed False
check_program: 
# In this coding exercise, we write a python function which given two strings, interlace strings by creating a new string with characters alternating between the original strings. The first character in the interlaces string should be from str1.. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'interlace_strings' will take the arguments 'str1', a string and 'str2', a string. It will return an interlaced string.
def interlace_strings(str1, str2):

    a = ""
    b = ""
    for i in range(len(max(str1,str2))):
        a += str1[i] if i < len(str1) else ""
        b += str2[i] if i < len(str2) else ""
    return a+b

def check(interlace_strings):
    assert interlace_strings('abcd', '1234') == 'a1b2c3d4'
    assert interlace_strings('a', '1234') == 'a1234'
    assert interlace_strings('abcd', '12') == 'a1b2cd'

check(interlace_strings)
result : failed: AssertionError
solution 9 passed False
Task 15 gens 1 solutions in cir 0
check_program: 
# In this coding exercise, we write a python function which determines if a string is a (case sensitive) permutation of another string. We do not use augmented assignment operations (+=, *=, etc.) for clarity.
# The function 'is_permutation' will take the arguments 'str1', a string and 'str2', a string. It will return a boolean indicating if the strings were permutations.
def is_permutation(str1, str2):

    return sorted(str1) == sorted(str2)

def check(is_permutation):
    assert is_permutation('abcde', 'abcde') == True
    assert is_permutation('BIN', 'bin') == False
    assert is_permutation('act', 'cat') == True
    assert is_permutation('dog', 'doggo') == False
    assert is_permutation('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'XFBNbfsxuCikOPvaTYhmKHcgZAdrnMGRSeQoIyEtUVqjlzwpWDLJ') == True
    assert is_permutation('', '') == True

check(is_permutation)
result : passed
solution 0 passed True
task_has_solution: dict_keys([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
cir 0,passed 6 tasks, pass rate is 0.375
pass tasks are:
[1, 2, 4, 6, 8, 15]
cir 1,passed 9 tasks, pass rate is 0.5625
pass tasks are:
[0, 1, 2, 4, 5, 6, 8, 14, 15]
cir 2,passed 9 tasks, pass rate is 0.5625
pass tasks are:
[0, 1, 2, 4, 5, 6, 8, 14, 15]
cir 3,passed 10 tasks, pass rate is 0.625
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 14, 15]
cir 4,passed 10 tasks, pass rate is 0.625
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 14, 15]
cir 5,passed 10 tasks, pass rate is 0.625
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 14, 15]
cir 6,passed 10 tasks, pass rate is 0.625
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 14, 15]
cir 7,passed 11 tasks, pass rate is 0.6875
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 15]
cir 8,passed 11 tasks, pass rate is 0.6875
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 15]
cir 9,passed 11 tasks, pass rate is 0.6875
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 15]
cir 10,passed 11 tasks, pass rate is 0.6875
pass tasks are:
[0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 15]
task 0 pass or not for each cir: [False, True, True, True, True, False, False, False, False, False, False]
task 1 pass or not for each cir: [True]
task 2 pass or not for each cir: [True]
task 3 pass or not for each cir: [False, False, False, True, True, True, False, False, False]
task 4 pass or not for each cir: [True]
task 5 pass or not for each cir: [False, True]
task 6 pass or not for each cir: [True]
task 7 pass or not for each cir: [False]
task 8 pass or not for each cir: [True, True, True, True, True, True, True, True, True, True, True]
task 9 pass or not for each cir: [False]
task 10 pass or not for each cir: [False, False, False, False, False, False, False, False, False, False, False]
task 11 pass or not for each cir: [False, False, False, False, False, False, False, True, True, False, True]
task 12 pass or not for each cir: [False, False, False, False, False, False, False, False, False, False, False]
task 13 pass or not for each cir: [False, False, False, False, False, False, False, False, False, False, False]
task 14 pass or not for each cir: [False, True, True, True, True, True, False, False, False, False, False]
task 15 pass or not for each cir: [True]
--------------------------------------------
lack task : [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
pass task num: [6, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11]
pass task rate: [0.375, 0.5625, 0.5625, 0.625, 0.625, 0.625, 0.625, 0.6875, 0.6875, 0.6875, 0.6875]
cir 0, pass at k 15 rate: 0.375
cir 1, pass at k 15 rate: 0.4444444444444444
cir 2, pass at k 15 rate: 0.375
cir 3, pass at k 15 rate: 0.5
cir 4, pass at k 15 rate: 0.5
cir 5, pass at k 15 rate: 0.375
cir 6, pass at k 15 rate: 0.125
cir 7, pass at k 15 rate: 0.25
cir 8, pass at k 15 rate: 0.25
cir 9, pass at k 15 rate: 0.14285714285714285
cir 10, pass at k 15 rate: 0.2857142857142857
38
{20, 26, 31, 34, 39, 40, 44, 47, 48, 49, 52, 55, 61, 62, 64, 66, 68, 71, 73, 74, 75, 78, 80, 82, 83, 86, 88, 93, 95, 97, 99, 101, 103, 104, 111, 113, 114, 115, 116, 118, 119, 120, 122, 125, 126, 128, 129, 131, 133, 136, 139, 143, 145, 146, 153, 154, 156, 165, 166, 169, 172, 173, 174, 177, 178, 180, 182, 183, 187, 189, 190, 192, 198, 199, 204, 209, 210, 219, 220, 221, 223, 224, 226, 229, 234, 235, 247, 248, 249, 250, 251, 257, 260, 263, 264, 266, 269, 274, 276, 279, 280, 283, 289, 297, 298, 300, 301, 302, 307, 308, 309, 315, 319, 320, 321, 323, 325, 326, 330, 332, 334, 335, 336, 337, 345, 349, 350, 361, 362, 363, 365, 366, 367, 371, 372, 373, 374, 375, 377, 379, 381, 382, 383, 385, 387, 388, 391, 394, 396, 398, 399, 401, 405, 406, 407, 409, 410, 413, 416, 417, 420, 421, 422, 423, 427, 428, 429, 430, 436, 438, 443, 446, 449, 452, 454, 455, 457, 459, 461, 465, 468, 469, 473, 476, 481, 482, 483, 484, 486, 488, 489, 490, 491, 497, 503, 505, 507, 508}
